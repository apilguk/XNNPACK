// Copyright 2021 Google LLC
//
// This source code is licensed under the BSD-style license found in the
// LICENSE file in the root directory of this source tree.

$from itertools import chain
$import math
$assert SIZE in [8, 16, 32, 64]
$TILE_SIZE=int(128/SIZE)
$NUM_ITER = int(math.log2(TILE_SIZE))
$LO_PERM=str(list(chain.from_iterable((i, i+TILE_SIZE) for i in range((TILE_SIZE>>1)))))[1:-1]
$HI_PERM=str(list(chain.from_iterable(((TILE_SIZE>>1)+i, (TILE_SIZE>>1)+i+TILE_SIZE) for i in range((TILE_SIZE>>1)))))[1:-1]

#include <wasm_simd128.h>

#include <assert.h>

#include <xnnpack/common.h>
#include <xnnpack/math.h>
#include <xnnpack/transpose.h>

void xnn_x${SIZE}_transpose_ukernel__${TILE_SIZE}x${TILE_SIZE}_wasmsimd(
    const uint${SIZE}_t *input,
    uint${SIZE}_t * output,
    size_t input_stride,
    size_t output_stride,
    size_t block_width,
    size_t block_height)
{
  assert(output_stride >= block_height * sizeof(uint${SIZE}_t));
  assert(input_stride >= block_width * sizeof(uint${SIZE}_t));
  const size_t tile_height = ${TILE_SIZE};
  const size_t tile_width = ${TILE_SIZE};
  const size_t tile_hbytes = tile_height * sizeof(uint${SIZE}_t);
  const size_t tile_wbytes = tile_width * sizeof(uint${SIZE}_t);
  $if SIZE >= 32:
    const size_t input_reset = tile_wbytes - round_down_po2(block_height, tile_height) * input_stride;
  $else:
    const size_t input_reset = tile_wbytes - (block_height - ((block_height % tile_height) != 0)) * input_stride;
  const size_t output_reset = tile_width * output_stride - round_down_po2(block_height, 2) * sizeof(uint${SIZE}_t);
  $if SIZE >= 32:
    const size_t input_offset = tile_height * input_stride;
  const uint${SIZE}_t* i0 = input;
  $if SIZE >= 32:
    $for N in range(1, TILE_SIZE):
      const uint${SIZE}_t* i${N} = (const uint${SIZE}_t*) ((uintptr_t) i${N-1} + input_stride);
  uint${SIZE}_t* o0 = (uint${SIZE}_t*) output;
  $if SIZE >= 32:
    $for N in range(1, TILE_SIZE):
      uint${SIZE}_t* o${N} = (uint${SIZE}_t*) ((uintptr_t) o${N-1} + output_stride);
  do {
    $if SIZE >= 32:
      if XNN_UNPREDICTABLE(block_width < 2) {
        o1 = o0;
      }
      $for N in range(2, TILE_SIZE, 2):
        if XNN_UNPREDICTABLE(block_width <= ${N}) {
          o${N} = o0;
        }
        if XNN_UNPREDICTABLE(block_width < ${N+2}) {
          o${N+1} = o0;
        }
    size_t bh = block_height;
    for (; bh >= ${TILE_SIZE}; bh -= ${TILE_SIZE}) {
      $for N in range(TILE_SIZE):
        $if SIZE >= 32:
          const v128_t v${NUM_ITER}_${N} = wasm_v128_load(i${N});
          i${N} = (uint${SIZE}_t*) ((uintptr_t) i${N} + input_offset);
        $else:
          const v128_t v${NUM_ITER}_${N} = wasm_v128_load(i0);
          i0 = (uint${SIZE}_t*) ((uintptr_t) i0 + input_stride);
      $for M in range(NUM_ITER):
        $for N in range(TILE_SIZE >> 1):
          const v128_t v${NUM_ITER-M-1}_${2*N} = wasm_v${SIZE}x${TILE_SIZE}_shuffle(v${NUM_ITER-M}_${N}, v${NUM_ITER-M}_${N+int(TILE_SIZE/2)}, ${LO_PERM});
          const v128_t v${NUM_ITER-M-1}_${2*N+1} = wasm_v${SIZE}x${TILE_SIZE}_shuffle(v${NUM_ITER-M}_${N}, v${NUM_ITER-M}_${N+int(TILE_SIZE/2)}, ${HI_PERM});
      $if SIZE >= 32:
        $for N in reversed(range(TILE_SIZE)):
          wasm_v128_store(o${N}, v0_${N});
          o${N} = (uint${SIZE}_t*) ((uintptr_t) o${N} + tile_hbytes);
      $else:
        size_t rem = min(block_width - 1, ${TILE_SIZE-1});
        uint${SIZE}_t* o1 = (uint${SIZE}_t*) ((uintptr_t) o0 + rem * output_stride);
        switch (rem) {
        $for N in reversed(range(2, TILE_SIZE)):
            case ${N}:
              wasm_v128_store(o1, v0_${N});
              o1 = (uint${SIZE}_t*) ((uintptr_t) o1 - output_stride);
        case 1:
          wasm_v128_store(o1, v0_1);
        }
        wasm_v128_store(o0, v0_0);
        o0 = (uint${SIZE}_t*) ((uintptr_t) o0 + tile_hbytes);
    }
    if (bh != 0) {
      $if SIZE >= 32:
        const v128_t v${NUM_ITER}_0 = wasm_v128_load(i0);
        $for N in range(1, TILE_SIZE - 1):
          if XNN_UNPREDICTABLE(bh < ${N+1}) {
            i${N} = i0;
          }
          const v128_t v${NUM_ITER}_${N} = wasm_v128_load(i${N});
      $else:
        $for N in range(TILE_SIZE - 1):
          const v128_t v${NUM_ITER}_${N} = wasm_v128_load(i0);
          if XNN_UNPREDICTABLE(bh > ${N+1}) {
            i0 = (uint${SIZE}_t*) ((uintptr_t) i0 + input_stride);
          }
      v128_t v${NUM_ITER}_${TILE_SIZE-1} = wasm_v128_xor(v${NUM_ITER}_0, v${NUM_ITER}_0);
      $for M in range(NUM_ITER):
        $for N in range(TILE_SIZE >> 1):
          v128_t v${NUM_ITER-M-1}_${2*N} = wasm_v${SIZE}x${TILE_SIZE}_shuffle(v${NUM_ITER-M}_${N}, v${NUM_ITER-M}_${N+int(TILE_SIZE/2)}, ${LO_PERM});
          v128_t v${NUM_ITER-M-1}_${2*N+1} = wasm_v${SIZE}x${TILE_SIZE}_shuffle(v${NUM_ITER-M}_${N}, v${NUM_ITER-M}_${N+int(TILE_SIZE/2)}, ${HI_PERM});
      $if SIZE < 32:
        size_t rem = min(block_width - 1, ${TILE_SIZE-1});
      if (bh & ${TILE_SIZE>>1}) {
        $if SIZE >= 32:
          $for N in reversed(range(TILE_SIZE)):
            *((double*) o${N}) = wasm_f64x2_extract_lane(v0_${N}, 0);
            $if SIZE != 64:
              o${N} += ${TILE_SIZE>>1};
        $else:
          uint${SIZE}_t* o1 = (uint${SIZE}_t*) ((uintptr_t) o0 + rem * output_stride);
          switch (rem) {
          $for N in reversed(range(2, TILE_SIZE)):
              case ${N}:
               *((double*) o1) = wasm_f64x2_extract_lane(v0_${N}, 0);
                o1 = (uint${SIZE}_t*) ((uintptr_t) o1 - output_stride);
          case 1:
            *((double*) o1) = wasm_f64x2_extract_lane(v0_1, 0);
          }
          *((double*) o0) = wasm_f64x2_extract_lane(v0_0, 0);
          o0 += ${TILE_SIZE>>1};
        $if SIZE != 64:
          $for N in range(TILE_SIZE):
            v0_${N} = wasm_v64x2_shuffle(v0_${N}, v0_${N}, 1, 1);
      }
      $if SIZE <= 32:
        if (bh & ${TILE_SIZE>>2}) {
          $if SIZE == 32:
            $for N in reversed(range(TILE_SIZE)):
              *((float*) o${N}) = wasm_f32x4_extract_lane(v0_${N}, 0);
          $else:
            uint${SIZE}_t* o1 = (uint${SIZE}_t*) ((uintptr_t) o0 + rem * output_stride);
            switch (rem) {
            $for N in reversed(range(2, TILE_SIZE)):
                case ${N}:
                  *((float*) o1) = wasm_f32x4_extract_lane(v0_${N}, 0);
                  o1 = (uint${SIZE}_t*) ((uintptr_t) o1 - output_stride);
            case 1:
              *((float*) o1) = wasm_f32x4_extract_lane(v0_1, 0);
            }
            *((float*) o0) = wasm_f32x4_extract_lane(v0_0, 0);
            o0 += ${TILE_SIZE>>2};
            $for N in range(TILE_SIZE):
              v0_${N} = wasm_u64x2_shr(v0_${N}, 32);
        }
      $if SIZE <= 16:
        if (bh & ${TILE_SIZE>>3}) {
          uint${SIZE}_t* o1 = (uint${SIZE}_t*) ((uintptr_t) o0 + rem * output_stride);
          switch (rem) {
          $for N in reversed(range(2, TILE_SIZE)):
              case ${N}:
                *((uint16_t*) o1) = wasm_i16x8_extract_lane(v0_${N}, 0);
                o1 = (uint${SIZE}_t*) ((uintptr_t) o1 - output_stride);
          case 1:
            *((uint16_t*) o1) = wasm_i16x8_extract_lane(v0_1, 0);
          }
          *((uint16_t*) o0) = wasm_i16x8_extract_lane(v0_0, 0);
          $if SIZE != 16:
            o0 += ${TILE_SIZE>>3};
            $for N in range(TILE_SIZE):
              v0_${N} = wasm_u32x4_shr(v0_${N}, 16);
        }
      $if SIZE == 8:
        if (bh & 1) {
          uint8_t* o1 = (uint8_t*) ((uintptr_t) o0 + rem * output_stride);
          switch (rem) {
          $for N in reversed(range(2, TILE_SIZE)):
              case ${N}:
                *o1 = wasm_i8x16_extract_lane(v0_${N}, 0);
                o1 = (uint8_t*) ((uintptr_t) o1 - output_stride);
          case 1:
            *o1 = wasm_i8x16_extract_lane(v0_1, 0);
          }
          *o0 = wasm_i8x16_extract_lane(v0_0, 0);
        }
    }
    i0 = (const uint${SIZE}_t*) ((uintptr_t) i0 + input_reset);
    $if SIZE >= 32:
      $for N in range(1, TILE_SIZE):
        i${N} = (const uint${SIZE}_t*) ((uintptr_t) i${N-1} + input_stride);
    o0 = (uint${SIZE}_t*) ((uintptr_t) o0 + output_reset);
    $if SIZE >= 32:
      $for N in range(1, TILE_SIZE):
        o${N} = (uint${SIZE}_t*) ((uintptr_t) o${N} + output_reset);
    block_width = doz(block_width, tile_width);
  } while (block_width != 0);
}

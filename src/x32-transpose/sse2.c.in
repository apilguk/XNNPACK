// Copyright 2021 Google LLC
//
// This source code is licensed under the BSD-style license found in the
// LICENSE file in the root directory of this source tree.

$assert TILE_HEIGHT >= 1
$assert TILE_WIDTH >= 1
$import math

#include <emmintrin.h>

#include <assert.h>

#include <xnnpack/common.h>
#include <xnnpack/math.h>
#include <xnnpack/transpose.h>

$NUM_ELEM=int(128/SIZE)
$POS = int(math.log2(TILE_HEIGHT))

void xnn_x${SIZE}_transpose_ukernel__${TILE_HEIGHT}x${TILE_WIDTH}_sse2(
    const uint${SIZE}_t *input,
    uint${SIZE}_t * output,
    size_t input_stride,
    size_t output_stride,
    size_t block_width,
    size_t block_height)
{
  assert(output_stride >= block_height * sizeof(uint${SIZE}_t));
  assert(input_stride >= block_width * sizeof(uint${SIZE}_t));

  const size_t tile_height = ${TILE_HEIGHT};
  const size_t tile_width = ${TILE_WIDTH};
  const size_t tile_hbytes = tile_height * sizeof(uint${SIZE}_t);
  const size_t tile_wbytes = tile_width * sizeof(uint${SIZE}_t);
  $if SIZE >= 32:
    const size_t input_reset = tile_wbytes - round_down_po2(block_height, tile_height) * input_stride;
  $else:
    const size_t input_reset = tile_wbytes - (block_height - ((block_height % tile_height) != 0)) * input_stride;
  const size_t output_reset = tile_width * output_stride - round_down_po2(block_height, 2) * sizeof(uint${SIZE}_t);
  $if SIZE >= 32:
    const size_t input_offset = tile_height * input_stride;

  const uint${SIZE}_t* i0 = input;
  $if SIZE >= 32:
    $for N in range(1, TILE_HEIGHT):
      const uint${SIZE}_t* i${N} = (const uint${SIZE}_t*) ((uintptr_t) i${N-1} + input_stride);

  uint${SIZE}_t* o0 = (uint${SIZE}_t*) output;
  $if SIZE >= 32:
    $for N in range(1, TILE_WIDTH):
      uint${SIZE}_t* o${N} = (uint${SIZE}_t*) ((uintptr_t) o${N-1} + output_stride);

  do {
    $if SIZE >= 32:
      if XNN_UNPREDICTABLE(block_width < 2) {
        o1 = o0;
      }
      $for N in range(2, TILE_WIDTH, 2):
        if XNN_UNPREDICTABLE(block_width <= ${N}) {
          o${N} = o0;
        }
        if XNN_UNPREDICTABLE(block_width < ${N+2}) {
          o${N+1} = o0;
        }
    size_t bh = block_height;
    for (; bh >= ${TILE_HEIGHT}; bh -= ${TILE_HEIGHT}) {
      $for N in range(TILE_HEIGHT):
        $if SIZE >= 32:
          const __m128i v${N} = _mm_loadu_si128((const __m128i*) i${N});
          i${N} = (uint${SIZE}_t*) ((uintptr_t) i${N} + input_offset);
        $else:
          const __m128i v${N} = _mm_loadu_si128((const __m128i*) i0);
          i0 = (uint${SIZE}_t*) ((uintptr_t) i0 + input_stride);

      $for N in range(TILE_HEIGHT >> 1):
        __m128i v${SIZE}_${N*2} = _mm_unpacklo_epi${SIZE}(v${N*2}, v${N*2+1});
        __m128i v${SIZE}_${N*2+1} = _mm_unpackhi_epi${SIZE}(v${N*2}, v${N*2+1});

      $if SIZE <= 32:
        $for N in range(0, TILE_HEIGHT, 4):
          const __m128i v${SIZE*2}_${N} = _mm_unpacklo_epi${SIZE*2}(v${SIZE}_${N}, v${SIZE}_${N+2});
          const __m128i v${SIZE*2}_${N+1} = _mm_unpackhi_epi${SIZE*2}(v${SIZE}_${N}, v${SIZE}_${N+2});
          const __m128i v${SIZE*2}_${N+2} = _mm_unpacklo_epi${SIZE*2}(v${SIZE}_${N+1}, v${SIZE}_${N+3});
          const __m128i v${SIZE*2}_${N+3} = _mm_unpackhi_epi${SIZE*2}(v${SIZE}_${N+1}, v${SIZE}_${N+3});
      $if SIZE <= 16:
        $for M in range(0, TILE_HEIGHT, 8):
          $for N in range(0, 4):
            const __m128i v${SIZE*4}_${M+2*N} = _mm_unpacklo_epi${SIZE*4}(v${SIZE*2}_${M+N}, v${SIZE*2}_${M+N+4});
            const __m128i v${SIZE*4}_${M+2*N+1} = _mm_unpackhi_epi${SIZE*4}(v${SIZE*2}_${M+N}, v${SIZE*2}_${M+N+4});
      $if SIZE == 8:
        $for N in range(0, int(TILE_HEIGHT/2), 1):
          const __m128i v64_${N*2} = _mm_unpacklo_epi64(v32_${N}, v32_${N+8});
          const __m128i v64_${N*2+1} = _mm_unpackhi_epi64(v32_${N}, v32_${N+8});

      $if SIZE >= 32:
        $for N in reversed(range(NUM_ELEM)):
          _mm_storeu_si128((__m128i*) o${N}, v64_${N});
          o${N} = (uint${SIZE}_t*) ((uintptr_t) o${N} + tile_hbytes);
      $else:
        size_t rem = min(block_width - 1, ${TILE_WIDTH-1});
        uint16_t* o1 = (uint16_t*) ((uintptr_t) o0 + rem * output_stride);
        switch(rem){
        $for N in reversed(range(2, NUM_ELEM)):
            case (${N}):
              _mm_storeu_si128((__m128i*) o1, v64_${N});
              o1 = (uint16_t*) ((uintptr_t) o1 - output_stride);
        case (1):
          _mm_storeu_si128((__m128i*) o1, v64_1);
        }
        _mm_storeu_si128((__m128i*) o0, v64_0);
        o0 = (uint${SIZE}_t*) ((uintptr_t) o0 + tile_hbytes);
    }

    if (bh != 0) {
      $if SIZE >= 32:
        const __m128i v0 = _mm_loadu_si128((const __m128i*) i0);
        $for N in range(1, TILE_HEIGHT - 1):
          if XNN_UNPREDICTABLE(bh < ${N+1}) {
            i${N} = i0;
          }
          const __m128i v${N} = _mm_loadu_si128((const __m128i*) i${N});
      $else:
        $for N in range(TILE_HEIGHT - 1):
          const __m128i v${N} = _mm_loadu_si128((const __m128i*) i0);
          if XNN_UNPREDICTABLE(bh > ${N+1}) {
            i0 = (uint${SIZE}_t*) ((uintptr_t) i0 + input_stride);
          }
      __m128i v${TILE_HEIGHT-1} = _mm_setzero_si128();

      $for N in range(TILE_HEIGHT >> 1):
        const __m128i v${SIZE}_${N*2} = _mm_unpacklo_epi${SIZE}(v${N*2}, v${N*2+1});
        const __m128i v${SIZE}_${N*2+1} = _mm_unpackhi_epi${SIZE}(v${N*2}, v${N*2+1});

      $if SIZE <= 32:
        $for N in range(0, TILE_HEIGHT, 4):
          __m128i v${SIZE*2}_${N} = _mm_unpacklo_epi${SIZE*2}(v${SIZE}_${N}, v${SIZE}_${N+2});
          __m128i v${SIZE*2}_${N+1} = _mm_unpackhi_epi${SIZE*2}(v${SIZE}_${N}, v${SIZE}_${N+2});
          __m128i v${SIZE*2}_${N+2} = _mm_unpacklo_epi${SIZE*2}(v${SIZE}_${N+1}, v${SIZE}_${N+3});
          __m128i v${SIZE*2}_${N+3} = _mm_unpackhi_epi${SIZE*2}(v${SIZE}_${N+1}, v${SIZE}_${N+3});
      $if SIZE <= 16:
        $for M in range(0, TILE_HEIGHT, 8):
          $for N in range(0, 4):
            __m128i v${SIZE*4}_${M+2*N} = _mm_unpacklo_epi${SIZE*4}(v${SIZE*2}_${M+N}, v${SIZE*2}_${M+N+4});
            __m128i v${SIZE*4}_${M+2*N+1} = _mm_unpackhi_epi${SIZE*4}(v${SIZE*2}_${M+N}, v${SIZE*2}_${M+N+4});
      $if SIZE == 8:
        $for N in range(0, int(TILE_HEIGHT/2), 1):
          __m128i v64_${N*2} = _mm_unpacklo_epi64(v32_${N}, v32_${N+8});
          __m128i v64_${N*2+1} = _mm_unpackhi_epi64(v32_${N}, v32_${N+8});

      $if SIZE < 32:
        size_t rem = min(block_width - 1, ${TILE_WIDTH-1});
      if (bh & ${NUM_ELEM>>1}) {
        $if SIZE >= 32:
          $for N in reversed(range(NUM_ELEM)):
            _mm_storel_epi64((__m128i*) o${N}, v64_${N});
            $if SIZE != 64:
              o${N} += ${NUM_ELEM>>1};
        $else:
          uint${SIZE}_t* o1 = (uint${SIZE}_t*) ((uintptr_t) o0 + rem * output_stride);
          switch(rem){
          $for N in reversed(range(2, NUM_ELEM)):
              case (${N}):
                _mm_storel_epi64((__m128i*) o1, v64_${N});
                o1 = (uint${SIZE}_t*) ((uintptr_t) o1 - output_stride);
          case (1):
            _mm_storel_epi64((__m128i*) o1, v64_1);
          }
          _mm_storel_epi64((__m128i*) o0, v64_0);
          o0 += ${NUM_ELEM>>1};
        $if SIZE != 64:
          $for N in range(TILE_HEIGHT):
            v64_${N} = _mm_unpackhi_epi64(v64_${N}, v64_${N});
      }

      $if SIZE <= 32:
        if (bh & ${NUM_ELEM>>2}) {
          $if SIZE == 32:
            $for N in reversed(range(NUM_ELEM)):
              *((int*) o${N}) = _mm_cvtsi128_si32(v64_${N});
          $else:
            uint${SIZE}_t* o1 = (uint${SIZE}_t*) ((uintptr_t) o0 + rem * output_stride);
            switch(rem){
            $for N in reversed(range(2, NUM_ELEM)):
                case (${N}):
                  *((int*) o1) = _mm_cvtsi128_si32(v64_${N});
                  o1 = (uint${SIZE}_t*) ((uintptr_t) o1 - output_stride);
            case (1):
              *((int*) o1) = _mm_cvtsi128_si32(v64_1);
            }
            *((int*) o0) = _mm_cvtsi128_si32(v64_0);
            o0 += ${NUM_ELEM>>2};
            $for N in range(TILE_HEIGHT):
              v64_${N} = _mm_srli_epi64(v64_${N}, 32);
        }
      $if SIZE <= 16:
        if (bh & ${NUM_ELEM>>3}) {
          uint${SIZE}_t* o1 = (uint${SIZE}_t*) ((uintptr_t) o0 + rem * output_stride);
          switch(rem){
          $for N in reversed(range(2, NUM_ELEM)):
              case (${N}):
                *((uint16_t*) o1) = (uint16_t) _mm_cvtsi128_si32(v64_${N});
                o1 = (uint${SIZE}_t*) ((uintptr_t) o1 - output_stride);
          case (1):
            *((uint16_t*) o1) = (uint16_t) _mm_cvtsi128_si32(v64_1);
          }
          *((uint16_t*) o0) = (uint16_t) _mm_cvtsi128_si32(v64_0);
          $if SIZE != 16:
            o0 += ${NUM_ELEM>>3};
            $for N in range(TILE_HEIGHT):
              v64_${N} = _mm_srli_epi32(v64_${N}, 16);
        }
      $if SIZE == 8:
        if (bh & 1) {
          uint${SIZE}_t* o1 = (uint${SIZE}_t*) ((uintptr_t) o0 + rem * output_stride);
          switch(rem){
          $for N in reversed(range(2, NUM_ELEM)):
              case (${N}):
                *o1 = (uint8_t) _mm_cvtsi128_si32(v64_${N});
                o1 = (uint${SIZE}_t*) ((uintptr_t) o1 - output_stride);
          case (1):
            *o1 = (uint8_t) _mm_cvtsi128_si32(v64_1);
          }
          *o0 = (uint8_t) _mm_cvtsi128_si32(v64_0);
        }
    }

    i0 = (const uint${SIZE}_t*) ((uintptr_t) i0 + input_reset);
    $if SIZE >= 32:
      $for N in range(1, TILE_HEIGHT):
        i${N} = (const uint${SIZE}_t*) ((uintptr_t) i${N-1} + input_stride);
    o0 = (uint${SIZE}_t*) ((uintptr_t) o0 + output_reset);
    $if SIZE >= 32:
      $for N in range(1, TILE_HEIGHT):
        o${N} = (uint${SIZE}_t*) ((uintptr_t) o${N} + output_reset);
    block_width = doz(block_width, tile_width);
  } while (block_width != 0);
}
